## 泛型
#### 定义：函数的返回值，和参数的类型是相同的。函数调用的时候传入类型T
#### 作用：实现代码的高度复用性，使得程序变得灵活。

#### 实际使用
* 在定义函数或者类的时候，如果遇到类型不明确就可以使用泛型
#### 代码：
* 泛型函数
```
定义了一个函数fn,类型为T，参数返回值都为T
        function fn<T>(a: T):T{ 
            return a;
        }
       1:  fn(a:10); 
                    ts 可以自动识别a的类型为number，从而确定函数的T:number
               
       2: fn<number>(a: 10)
                    调用函数，确定类型。
    
        function<T1, T2>(a: T1, b:T2): T1 {
            return a
        }
```
* 泛型类
```
 class Person<T> {
     public name:string = '';    list 是一个数组。里面的元素类型为T；
     add(value: T):void {   函数没有返回值
        this.name = value
     }
     min():T{                函数的返回值是min，返回值的类型为T
         let min = 0;
         return min
     }
 }

 const xiaoming =new Person(String); 实例化了一个person，制定了类的T代表的的类型是String

```
* 接口和泛型
```
    interface InterFace{
        length:number;
    }
    泛型T必须是InterFace的实现类
    function fn<T extends InterFace>(a: T): number{
        return a.length;
    }
    fn(a: '123) || fn(a: {length: 3})
    将接口的定义和函数的函数联系起来，传入的参数必须符合接口的定义
```