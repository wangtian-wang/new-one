##  发布订阅模式 

### 实现思路

		* 需要一个第三方的observer
		* 

### 代码

```javascript
class Observer {
    constructor() {
        this.message = {
            // click： [fn1, fn2]
        }
    }
    on (type, fn){
        if (!this.message[type]){
            this.message[type] = []
        }
        this.message.push(fn)
    }
    off(type, fn) {
         某种类型的事件是否存在, 不存在事件，直接删除掉type 
        if (!fn) {
            delete this.message[type];
            return
        }
        if (!this.message[type]) return // 
        this.message[type] = this.message[type].filter(item => {
            item !== fn
        })
    }
    trigger(type, fn){
        if ( !type || !fn ) return;
        if (type && fn) {
            this.message[type].forEach( item => {
                if ( item === fn) {
                    item()
                }
            })
        }
        if (!Object.keys(this.message.length > 0)) return ;
        this.message[type]，forEach( fn => {
            fn()
        })
        
    }
}

function handler1 () {};
function handler2() {}
```



### 与观察者模式的区别

```javascript
观察者模式只有两个构造函数
1 ： 被观察者
	  做出了某些行为，会让观察者观察到自己
      特点： 1： 可能被多个人观察
      		2: 必须做出一定的行为
            3： 
      		
      
2：  观察者
      特点： 1：必须监听被观察者
      		2： 监听到了事件之后出发某项操作。
发布订阅模式
1： 只有一个第三方的通信者  observer
 这个监听者类似于浏览器上面的事件监听机制，监听到某项事件，触发对应的事件处理函数。 事件机制
```

```

```



