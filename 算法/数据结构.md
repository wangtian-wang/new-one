前端需要掌握的数据结构

### 队列
###### 普通队列结构
  ###### 数据结构的特点
      ```js
        start                           end
        only delete element            only add new element
        插入或者删除一个元素的时候，需要处理其他的元素。

      ```
  ###### 实际应用
  * 击鼓传花

    ```js
     代码实现
     function HitDrum（nameList, num) {
       var queueInstance = new Queue();
       for (var i = 0;i< num -1; i++){
         queueInstance.enqueue(nameList[i])
       }
       /* 每num个一循环，保留num-1位人， 重新加入队列中，删除num对应的这个人*/
       while(queueInstance.length > 1) { 
         for (var i = 0; i< num -1; i++) {
           qunueInstance.enqueue(queueInstance.dequeue())
         }
         queueInstance.dequeue()
       }

       const finallyRes = queueInstance.front();//  将最后剩下的人的名字找到
       return nameList.indexOf(finallyRes) // 将最后剩下的人的索引返回
     }
    ```

###### 优先级队列结构

###### 数据结构的特点
    ```js
       会根据新插入数据的优先级和其他数据进行比较
       比较完成后可以得出这个元素在队列中的正确位置
          主要考虑问题
            1： 每个元素包含数据的优先级
            2： 在添加方式中，根据优先级放入正确的位置
    ```

###### 实际应用
    ```js
      登记顺序
      急诊室的候诊顺序
      计算机中的线程
    ```
###### 代码实现
  ```js
     优先级队列
     function PriorityQueue(){
       /* 内部类， 用来记录每个队列元素和优先级*/
       function QueueElem(elem,priority) {
         this.elem = elem;
         this.priority = priority;
       }
       this.items = [];
       PriorityQueue.prototype.enqueue = function (elem,priority) {
         var queueElem = new PriorityQueue(elem,priority)
       }

     }
  ````
  














##### 栈结构
###### 普通队列结构
  ###### 数据结构的特点
      ```js
        start                           end
        only delete element            only add new element
        插入或者删除一个元素的时候，需要处理其他的元素。

      ```
  ###### 实际应用
  * 击鼓传花

    ```js
     代码实现
     function HitDrum（nameList, num) {
       var queueInstance = new Queue();
       for (var i = 0;i< num -1; i++){
         queueInstance.enqueue(nameList[i])
       }
       /* 每num个一循环，保留num-1位人， 重新加入队列中，删除num对应的这个人*/
       while(queueInstance.length > 1) { 
         for (var i = 0; i< num -1; i++) {
           qunueInstance.enqueue(queueInstance.dequeue())
         }
         queueInstance.dequeue()
       }

       const finallyRes = queueInstance.front();//  将最后剩下的人的名字找到
       return nameList.indexOf(finallyRes) // 将最后剩下的人的索引返回
     }
    ```

###### 优先级队列结构

###### 数据结构的特点
    ```js
       会根据新插入数据的优先级和其他数据进行比较
       比较完成后可以得出这个元素在队列中的正确位置
          主要考虑问题
            1： 每个元素包含数据的优先级
            2： 在添加方式中，根据优先级放入正确的位置
    ```

###### 实际应用
    ```js
      登记顺序
      急诊室的候诊顺序
      计算机中的线程
    ```
###### 代码实现
  ```js
  ````
  

    





##### 链表

##### 二叉树

